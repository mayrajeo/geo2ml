# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/11_data.coordinates.ipynb.

# %% auto 0
__all__ = ['list_to_affine', 'get_geo_transform', 'convert_poly_coords', 'affine_transform_gdf', 'gdf_to_px', 'georegister_px_df']

# %% ../../nbs/11_data.coordinates.ipynb 3
import affine
import rasterio as rio
from osgeo import gdal
import geopandas as gpd
import pandas as pd
import shapely
from shapely.geometry import shape
from shapely.geometry import mapping
import os
import numpy as np

# %% ../../nbs/11_data.coordinates.ipynb 4
def list_to_affine(xform_mat: list) -> affine.Affine:
    "Adapted from Solaris.geo. Creates an affine object from array-formatted list"
    if len(xform_mat) > 6:
        xform_mat = xform_mat[:6]
    if rio.transform.tastes_like_gdal(xform_mat):
        return affine.Affine.from_gdal(*xform_mat)
    else:
        return affine.Affine(*xform_mat)

# %% ../../nbs/11_data.coordinates.ipynb 5
def get_geo_transform(src) -> affine.Affine:
    "Extract geotransform for a raster image source"
    if isinstance(raster, str):
        return rio.open(raster_src).transform
    elif isinstance(raster_src, rio.DatasetReader):
        return raster_src.transform
    elif isinstance(raster_src, gdal.Dataset):
        return affine.Affine.from_gdal(*raster_src.GetGeoTransform())

# %% ../../nbs/11_data.coordinates.ipynb 6
def _reduce_geom_precision(geom, precision=2):
    "From solaris.utils.geo. Reduces precision of the coordinates."
    geojson = mapping(geom)
    geojson["coordinates"] = np.round(np.array(geojson["coordinates"]), precision)
    return shape(geojson)

# %% ../../nbs/11_data.coordinates.ipynb 7
def convert_poly_coords(
    geom: shape,
    raster_src: str = None,
    affine_obj: affine.Affine = None,
    inverse: bool = False,
    precision=None,
) -> shape:
    "Adapted from solaris. Converts georeferenced coordinates to pixel coordinates and vice versa"
    if not raster_src and not affine_obj:
        raise ValueError("Either raster_src or affine_obj must be provided.")

    if raster_src is not None:
        affine_xform = get_geo_transform(raster_src)
    else:
        if isinstance(affine_obj, affine.Affine):
            affine_xform = affine_obj
        else:
            # assume it's a list in either gdal or "standard" order
            # (list_to_affine checks which it is)
            if len(affine_obj) == 9:  # if it's straight from rasterio
                affine_obj = affine_obj[0:6]
            affine_xform = list_to_affine(affine_obj)

    if inverse:  # geo->px transform
        affine_xform = ~affine_xform

    if isinstance(geom, str):
        # get the polygon out of the wkt string
        g = shapely.wkt.loads(geom)
    elif isinstance(geom, shapely.geometry.base.BaseGeometry):
        g = geom
    else:
        raise TypeError(
            "The provided geometry is not an accepted format. "
            "This function can only accept WKT strings and "
            "shapely geometries."
        )

    xformed_g = shapely.affinity.affine_transform(
        g,
        [
            affine_xform.a,
            affine_xform.b,
            affine_xform.d,
            affine_xform.e,
            affine_xform.xoff,
            affine_xform.yoff,
        ],
    )
    if isinstance(geom, str):
        # restore to wkt string format
        xformed_g = shapely.wkt.dumps(xformed_g)
    if precision is not None:
        xformed_g = _reduce_geom_precision(xformed_g, precision=precision)

    return xformed_g

# %% ../../nbs/11_data.coordinates.ipynb 8
def affine_transform_gdf(
    gdf: gpd.GeoDataFrame,
    affine_obj: affine.Affine,
    inverse: bool = False,
    geom_col: str = "geometry",
    precision: int = None,
) -> gpd.GeoDataFrame:
    """Adapted from solaris, transforms all geometries in GeoDataFrame to pixel coordinates from
    Georeferced coordinates and vice versa"""
    if "geometry" not in gdf.columns:
        gdf = gdf.rename(columns={geom_col: "geometry"})
    gdf["geometry"] = gdf["geometry"].apply(
        convert_poly_coords, affine_obj=affine_obj, inverse=inverse
    )
    if precision is not None:
        gdf["geometry"] = gdf["geometry"].apply(
            _reduce_geom_precision, precision=precision
        )

    # the CRS is no longer valid - remove it
    gdf.crs = None

    return gdf

# %% ../../nbs/11_data.coordinates.ipynb 9
def gdf_to_px(
    gdf: gpd.GeoDataFrame,
    im_path,
    geom_col: str = "geometry",
    precision: int = None,
    outpath=None,
    override_crs=False,
) -> gpd.GeoDataFrame:
    """Adapted from https://solaris.readthedocs.io/en/latest/_modules/solaris/vector/polygon.html#geojson_to_px_gdf
    Converts `gdf` to pixel coordinates based on image in `im_path`
    """

    with rio.open(im_path) as im:
        affine_obj = im.transform

    transformed_gdf = affine_transform_gdf(
        gdf, affine_obj=affine_obj, inverse=True, precision=precision, geom_col=geom_col
    )

    transformed_gdf["image_fname"] = os.path.split(im_path)[1]

    if outpath is not None:
        if outpath.lower().endswith("json"):
            transformed_gdf.to_file(outpath, driver="GeoJSON")
        else:
            transformed_gdf.to_csv(outpath, index=False)
    return transformed_gdf

# %% ../../nbs/11_data.coordinates.ipynb 10
def georegister_px_df(
    df: pd.DataFrame,
    im_path=None,
    affine_obj: affine.Affine = None,
    crs=None,
    geom_col: str = "geometry",
    precision: int = None,
    output_path=None,
) -> gpd.GeoDataFrame:
    "Convert geodataframe from pixel coordinates to `crs`, using `affine_obj` as the reference"
    with rio.open(im_path) as im:
        affine_obj = im.transform
        crs = im.crs

    tmp_df = affine_transform_gdf(
        df, affine_obj, geom_col=geom_col, precision=precision
    )
    result = gpd.GeoDataFrame(tmp_df)
    result.set_crs(crs="epsg:" + str(crs.to_epsg()), allow_override=True, inplace=True)

    if output_path is not None:
        if output_path.lower().endswith("json"):
            result.to_file(output_path, driver="GeoJSON")
        else:
            result.to_csv(output_path, index=False)

    return result
